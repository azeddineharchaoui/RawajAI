"use client"

import { useState, useRef, useEffect } from "react"
import { Text, TextInput, ScrollView, StyleSheet, KeyboardAvoidingView, Platform, Alert } from "react-native"
import { WebSafeView } from "./WebSafeView"
import { WebSafeTouchableOpacity } from "./WebSafeTouchableOpacity"
import * as Speech from "expo-speech"
import * as DocumentPicker from "expo-document-picker"
import * as FileSystem from "expo-file-system"
import { FreeAIService } from "../services/freeAIService"
import { RealSpeechService } from "../services/fixedSpeechService"

interface Message {
  id: string
  text: string
  isUser: boolean
  timestamp: Date
  language: string
  hasAudio?: boolean
  isTyping?: boolean
}

interface Document {
  id: string
  name: string
  content: string
  type: string
  uploadDate: Date
}

interface ChatContext {
  messages: string[]
  currentTopic: string
  userPreferences: {
    language: string
    expertise: string
    interests: string[]
  }
}

// Syst√®me de mod√©ration renforc√©
const INAPPROPRIATE_WORDS = {
  fr: ["merde", "putain", "connard", "salope", "bordel", "con", "pute", "chier", "foutre"],
  ar: [ "ÿ≠ŸÖÿßÿ±", "ÿ∫ÿ®Ÿä", "ÿßÿ≠ŸÖŸÇ", "ŸÑÿπŸäŸÜ", "ŸÇÿ∞ÿ±"],
  darija: ["7mar", "kelb", "wa7ed", "khanzir", "7ayawan", "qalil"],
  en: ["fuck", "shit", "damn",  "asshole", "stupid", "idiot", "crap"],
}

// D√©tection de langue ultra-pr√©cise
const detectLanguageUltra = (text: string): "fr" | "en" | "ar" | "darija" => {
  const lowerText = text.toLowerCase()

  // Darija - Patterns tr√®s sp√©cifiques
  const darijaPatterns = [
    // Mots uniquement darija
    /\b(wa7ed|jouj|tlata|arb3a|khamsa|stta|sb3a|tmnya|ts3od|3ashra)\b/,
    /\b(dyali|dyalek|dyalo|dyalha|dyal|li|lli)\b/,
    /\b(hna|hnak|bach|wach|ila|daba|ghir|bghit|bghiti|bghina)\b/,
    /\b(katdir|katdiri|kandiro|kandir|ndir|tdiri)\b/,
    /\b(kifach|kifash|ash|ashno|3lash|mnin|fin)\b/,
    /\b(3andi|3andek|3ando|3andha|3andna|3andhum)\b/,
    /\b(f|mn|3la|m3a|b7al|b7ala|zay|kay)\b/,
    /salam.*kifach|ahlan.*ash|marhaba.*wach/,
    // M√©lange chiffres + darija
    /[0-9].*\b(dyali|dyal|bach|wach|3la|mn)\b/,
  ]

  if (darijaPatterns.some((pattern) => pattern.test(lowerText))) {
    return "darija"
  }

  // Arabe classique 
  if (/[\u0600-\u06FF]/.test(text) && !/[a-zA-Z0-9]/.test(text)) {
    return "ar"
  }

  // Anglais - Mots tr√®s fr√©quents
  const englishIndicators = [
    /\b(the|and|you|are|have|with|for|this|that|from|they|know|want|been|good|much|some|time|very|when|come|here|just|like|long|make|many|over|such|take|than|them|well|were)\b/g,
    /\b(hello|help|how|what|where|why|who|which|would|could|should|will|can|may|might)\b/g,
    /\b(forecast|inventory|supply|chain|logistics|transport|stock|warehouse|demand)\b/g,
  ]

  const englishMatches = englishIndicators.reduce((count, pattern) => {
    const matches = lowerText.match(pattern)
    return count + (matches ? matches.length : 0)
  }, 0)

  if (englishMatches >= 3) {
    return "en"
  }

  // Fran√ßais par d√©faut
  return "fr"
}

//hna ghatal9aw configuration RAAAAAAAG
// Syst√®me RAG ultra-intelligent
class UltraIntelligentRAG {
  private documents: Document[] = []
  private vectorStore: Map<string, { keywords: string[]; content: string; relevance: number }> = new Map()

  addDocument(doc: Document) {
    this.documents.push(doc)

    // Extraction de mots-cl√©s intelligente
    const keywords = this.extractKeywords(doc.content)
    const relevance = this.calculateRelevance(doc.content)

    this.vectorStore.set(doc.id, {
      keywords,
      content: doc.content,
      relevance,
    })

    console.log(`üìÑ Document index√©: ${doc.name} (${keywords.length} mots-cl√©s, relevance: ${relevance})`)
  }

  private extractKeywords(content: string): string[] {
    const supplyChainKeywords = [
      "stock",
      "inventaire",
      "inventory",
      "pr√©vision",
      "forecast",
      "tawaqo3",
      "transport",
      "logistique",
      "logistics",
      "livraison",
      "delivery",
      "co√ªt",
      "cost",
      "prix",
      "price",
      "demande",
      "demand",
      "talab",
      "fournisseur",
      "supplier",
      "client",
      "customer",
      "entrep√¥t",
      "warehouse",
      "commande",
      "order",
      "d√©lai",
      "lead time",
      "rotation",
      "turnover",
      "optimisation",
      "optimization",
      "ta7sin",
      "performance",
      "efficacit√©",
      "kpi",
      "m√©trique",
      "analytics",
      "donn√©es",
      "data",
      "analyse",
    ]

    const words = content.toLowerCase().split(/\s+/)
    const foundKeywords = words.filter((word) =>
      supplyChainKeywords.some((keyword) => word.includes(keyword) || keyword.includes(word)),
    )

    return [...new Set(foundKeywords)] // Supprimer les doublons
  }

  private calculateRelevance(content: string): number {
    const supplyChainTerms = [
      "supply chain",
      "cha√Æne d'approvisionnement",
      "logistique",
      "logistics",
      "stock",
      "inventaire",
      "pr√©vision",
      "forecast",
      "transport",
      "livraison",
    ]

    let relevance = 0
    const lowerContent = content.toLowerCase()

    supplyChainTerms.forEach((term) => {
      const matches = (lowerContent.match(new RegExp(term, "g")) || []).length
      relevance += matches * 10
    })

    return Math.min(relevance, 100) // Max 100
  }

  findBestMatch(query: string): { found: boolean; content: string; sources: string[]; confidence: number } {
    const queryWords = query.toLowerCase().split(/\s+/)
    const results: { doc: Document; score: number; matchedKeywords: string[] }[] = []

    for (const doc of this.documents) {
      const vectorData = this.vectorStore.get(doc.id)
      if (!vectorData) continue

      let score = 0
      const matchedKeywords: string[] = []

      // Score bas√© sur les mots-cl√©s
      queryWords.forEach((queryWord) => {
        vectorData.keywords.forEach((keyword) => {
          if (keyword.includes(queryWord) || queryWord.includes(keyword)) {
            score += 10
            matchedKeywords.push(keyword)
          }
        })
      })

      // Score bas√© sur le contenu direct
      const contentLower = doc.content.toLowerCase()
      queryWords.forEach((queryWord) => {
        const matches = (contentLower.match(new RegExp(queryWord, "g")) || []).length
        score += matches * 5
      })

      // Bonus pour la relevance du document
      score += vectorData.relevance * 0.1

      if (score > 0) {
        results.push({ doc, score, matchedKeywords })
      }
    }

    // Trier par score d√©croissant
    results.sort((a, b) => b.score - a.score)

    if (results.length === 0) {
      return { found: false, content: "", sources: [], confidence: 0 }
    }

    // Prendre les 2 meilleurs r√©sultats
    const topResults = results.slice(0, 2)
    const content = topResults
      .map((result) => {
        const lines = result.doc.content.split("\n")
        const relevantLines = lines
          .filter((line) => result.matchedKeywords.some((keyword) => line.toLowerCase().includes(keyword)))
          .slice(0, 3)

        return `**${result.doc.name}:**\n${relevantLines.join("\n")}`
      })
      .join("\n\n")

    const sources = topResults.map((result) => result.doc.name)
    const confidence = Math.min(topResults[0].score / 50, 1) // Normaliser sur 1

    return { found: true, content, sources, confidence }
  }

  getDocumentCount(): number {
    return this.documents.length
  }
}

export default function UltimateAdvancedAssistant() {
  const [messages, setMessages] = useState<Message[]>([
    {
      id: "1",
      text: "üöÄ Salut ! Je suis RawaJAI, ton assistant supply chain avec IA avanc√©e.\n\n‚ú® **Nouvelles fonctionnalit√©s ULTRA :**\n‚Ä¢ ü§ñ **APIs gratuites** - R√©ponses IA de qualit√©\n‚Ä¢ üé§ **Speech R√âEL** - Je comprends exactement ce que tu dis\n‚Ä¢ üß† **RAG intelligent** - Acc√®s direct √† tes documents\n‚Ä¢ üåç **D√©tection auto** - Langue d√©tect√©e automatiquement\n‚Ä¢ üí¨ **Chat contextuel** - Je me souviens de nos conversations\n\nDis 'aide' pour d√©couvrir toutes mes capacit√©s !",
      isUser: false,
      timestamp: new Date(),
      language: "fr",
    },
  ])

  const [inputText, setInputText] = useState("")
  const [isLoading, setIsLoading] = useState(false)
  const [isRecording, setIsRecording] = useState(false)
  const [currentLanguage, setCurrentLanguage] = useState<"fr" | "en" | "ar" | "darija">("fr")
  const [speechEnabled, setSpeechEnabled] = useState(true)
  const [documents, setDocuments] = useState<Document[]>([])
  const [isTyping, setIsTyping] = useState(false)

  // Services
  const aiService = useRef(new FreeAIService())
  const speechService = useRef(new RealSpeechService())
  const ragSystem = useRef(new UltraIntelligentRAG())
  const scrollViewRef = useRef<ScrollView>(null)

  // Contexte de conversation
  const [chatContext, setChatContext] = useState<ChatContext>({
    messages: [],
    currentTopic: "",
    userPreferences: {
      language: "fr",
      expertise: "beginner",
      interests: [],
    },
  })

  // Mod√©ration de contenu
  const moderateContent = (text: string, language: string): boolean => {
    const inappropriateWords = INAPPROPRIATE_WORDS[language as keyof typeof INAPPROPRIATE_WORDS] || []
    return inappropriateWords.some((word) => text.toLowerCase().includes(word.toLowerCase()))
  }

  // G√©n√©ration de r√©ponse ULTRA-intelligente
  const generateUltraResponse = async (query: string, language: "fr" | "en" | "ar" | "darija"): Promise<string> => {
    const lowerQuery = query.toLowerCase()

    // V√©rification de mod√©ration
    if (moderateContent(query, language)) {
      const moderationResponses = {
        fr: "üòä Restons professionnels s'il te pla√Æt ! Je suis l√† pour t'aider avec ta supply chain de mani√®re constructive.",
        en: "üòä Let's keep it professional please! I'm here to help with your supply chain constructively.",
        ar: "üòä ÿØÿπŸÜÿß ŸÜÿ≠ÿßŸÅÿ∏ ÿπŸÑŸâ ÿßŸÑÿßÿ≠ÿ™ÿ±ÿßŸÅŸäÿ© ŸÖŸÜ ŸÅÿ∂ŸÑŸÉ! ÿ£ŸÜÿß ŸáŸÜÿß ŸÑŸÖÿ≥ÿßÿπÿØÿ™ŸÉ ŸÅŸä ÿ≥ŸÑÿ≥ŸÑÿ© ÿßŸÑÿ™Ÿàÿ±ŸäÿØ ÿ®ÿ∑ÿ±ŸäŸÇÿ© ÿ®ŸÜÿßÿ°ÿ©.",
        darija: "üòä Khallina nkuno professionnels 3afak! Ana hna bach n3awnek f supply chain b tariqa constructive.",
      }
      return moderationResponses[language]
    }

    // V√©rifier si la question est hors contexte supply chain
    if (!isSupplyChainRelated(query)) {
      const redirectResponses = {
        fr: "üéØ Je suis sp√©cialis√© en supply chain ! Pose-moi plut√¥t des questions sur :\n‚Ä¢ üìä Pr√©visions et analyses\n‚Ä¢ üì¶ Gestion des stocks\n‚Ä¢ üöö Logistique et transport\n‚Ä¢ üìà Optimisation des processus\n\nComment puis-je t'aider dans ces domaines ?",
        en: "üéØ I specialize in supply chain! Ask me about:\n‚Ä¢ üìä Forecasting and analysis\n‚Ä¢ üì¶ Inventory management\n‚Ä¢ üöö Logistics and transport\n‚Ä¢ üìà Process optimization\n\nHow can I help you in these areas?",
        ar: "üéØ ÿ£ŸÜÿß ŸÖÿ™ÿÆÿµÿµ ŸÅŸä ÿ≥ŸÑÿ≥ŸÑÿ© ÿßŸÑÿ™Ÿàÿ±ŸäÿØ! ÿßÿ≥ÿ£ŸÑŸÜŸä ÿπŸÜ:\n‚Ä¢ üìä ÿßŸÑÿ™ŸÜÿ®ÿ§ ŸàÿßŸÑÿ™ÿ≠ŸÑŸäŸÑ\n‚Ä¢ üì¶ ÿ•ÿØÿßÿ±ÿ© ÿßŸÑŸÖÿÆÿ≤ŸàŸÜ\n‚Ä¢ üöö ÿßŸÑŸÑŸàÿ¨ÿ≥ÿ™Ÿäÿßÿ™ ŸàÿßŸÑŸÜŸÇŸÑ\n‚Ä¢ üìà ÿ™ÿ≠ÿ≥ŸäŸÜ ÿßŸÑÿπŸÖŸÑŸäÿßÿ™\n\nŸÉŸäŸÅ ŸäŸÖŸÉŸÜŸÜŸä ŸÖÿ≥ÿßÿπÿØÿ™ŸÉ ŸÅŸä Ÿáÿ∞Ÿá ÿßŸÑŸÖÿ¨ÿßŸÑÿßÿ™ÿü",
        darija:
          "üéØ Ana mutakhassis f supply chain! Soulni 3la:\n‚Ä¢ üìä Tawaqo3 w ta7lil\n‚Ä¢ üì¶ Tadbir stock\n‚Ä¢ üöö Logistique w transport\n‚Ä¢ üìà Ta7sin 3amaliyat\n\nKifach n9der n3awnek f had majalet?",
      }
      return redirectResponses[language]
    }

    // Recherche RAG intelligente
    const ragResult = ragSystem.current.findBestMatch(query)

    // Construire le contexte pour l'IA
    const context = chatContext.messages.slice(-5) // 5 derniers messages

    try {
      // Essayer d'abord les APIs gratuites
      const aiResponse = await aiService.current.generateResponse(query, language, context)

      // Enrichir avec les donn√©es RAG si disponibles
      if (ragResult.found && ragResult.confidence > 0.3) {
        return enrichResponseWithRAG(aiResponse, ragResult, language)
      }

      return aiResponse
    } catch (error) {
      console.error("Erreur g√©n√©ration IA:", error)
      // Fallback sur r√©ponse locale
      return generateLocalFallback(query, language, ragResult)
    }
  }

  // V√©rifier si la question concerne la supply chain
  const isSupplyChainRelated = (query: string): boolean => {
    const supplyChainTerms = [
      // Fran√ßais
      "stock",
      "inventaire",
      "pr√©vision",
      "logistique",
      "transport",
      "livraison",
      "fournisseur",
      "client",
      "entrep√¥t",
      "commande",
      "co√ªt",
      "prix",
      "demande",
      "optimisation",
      "performance",
      "efficacit√©",
      "kpi",
      "analyse",
      "donn√©es",
      "supply chain",
      "cha√Æne",
      "approvisionnement",
      "distribution",
      "procurement",

      // Anglais
      "inventory",
      "forecast",
      "logistics",
      "supplier",
      "customer",
      "warehouse",
      "order",
      "cost",
      "demand",
      "optimization",
      "analytics",
      "procurement",
      "distribution",
      "supply",
      "chain",
      "transportation",
      "delivery",

      // Arabe
      "ŸÖÿÆÿ≤ŸàŸÜ",
      "ÿ™ŸÜÿ®ÿ§",
      "ŸÑŸàÿ¨ÿ≥ÿ™Ÿäÿßÿ™",
      "ŸÖŸàÿ±ÿØ",
      "ÿπŸÖŸäŸÑ",
      "ŸÖÿ≥ÿ™ŸàÿØÿπ",
      "ÿ∑ŸÑÿ®",
      "ÿ™ŸÉŸÑŸÅÿ©",
      "ÿ∑ŸÑÿ®",
      "ÿ™ÿ≠ÿ≥ŸäŸÜ",
      "ÿ£ÿØÿßÿ°",
      "ŸÉŸÅÿßÿ°ÿ©",
      "ÿ™ÿ≠ŸÑŸäŸÑ",
      "ÿ®ŸäÿßŸÜÿßÿ™",
      "ÿ™Ÿàÿ±ŸäÿØ",
      "ÿ≥ŸÑÿ≥ŸÑÿ©",

      // Darija
      "stock",
      "tawaqo3",
      "logistique",
      "transport",
      "livraison",
      "fournisseur",
      "client",
      "entrep√¥t",
      "commande",
      "co√ªt",
      "prix",
      "talab",
      "ta7sin",
      "performance",
      "efficacit√©",
      "ta7lil",
      "data",
      "supply",
      "chain",
    ]

    const lowerQuery = query.toLowerCase()
    return supplyChainTerms.some((term) => lowerQuery.includes(term.toLowerCase()))
  }

  // Enrichir la r√©ponse avec les donn√©es RAG
  const enrichResponseWithRAG = (aiResponse: string, ragResult: any, language: string): string => {
    const ragIntros = {
      fr: `üìÑ **D'apr√®s tes documents** (confiance: ${Math.round(ragResult.confidence * 100)}%):\n\n${ragResult.content}\n\nü§ñ **Mon analyse IA:**\n${aiResponse}`,
      en: `üìÑ **From your documents** (confidence: ${Math.round(ragResult.confidence * 100)}%):\n\n${ragResult.content}\n\nü§ñ **My AI analysis:**\n${aiResponse}`,
      ar: `üìÑ **ŸÖŸÜ ŸÖÿ≥ÿ™ŸÜÿØÿßÿ™ŸÉ** (ÿßŸÑÿ´ŸÇÿ©: ${Math.round(ragResult.confidence * 100)}%):\n\n${ragResult.content}\n\nü§ñ **ÿ™ÿ≠ŸÑŸäŸÑŸä ÿ®ÿßŸÑÿ∞ŸÉÿßÿ° ÿßŸÑÿßÿµÿ∑ŸÜÿßÿπŸä:**\n${aiResponse}`,
      darija: `üìÑ **Mn watha2eq dyalek** (thiqa: ${Math.round(ragResult.confidence * 100)}%):\n\n${ragResult.content}\n\nü§ñ **Ta7lili b AI:**\n${aiResponse}`,
    }

    return ragIntros[language]
  }

  // R√©ponse locale de secours
  const generateLocalFallback = (query: string, language: string, ragResult: any): string => {
    if (ragResult.found) {
      return enrichResponseWithRAG("Analyse bas√©e sur tes donn√©es.", ragResult, language)
    }

    // R√©ponses locales intelligentes comme avant
    const lowerQuery = query.toLowerCase()

    if (/bonjour|salut|hello|hi|salam|ahlan|marhaba/.test(lowerQuery)) {
      const greetings = {
        fr: "üåü Salut ! Je suis RawaJAI, ton expert supply chain avec IA avanc√©e. Comment puis-je optimiser ta logistique aujourd'hui ?",
        en: "üåü Hey! I'm RawaJAI, your supply chain expert with advanced AI. How can I optimize your logistics today?",
        ar: "üåü ÿ£ŸáŸÑÿßŸã! ÿ£ŸÜÿß ÿ±ÿßŸàÿß ÿ¨ÿßŸäÿå ÿÆÿ®Ÿäÿ±ŸÉ ŸÅŸä ÿ≥ŸÑÿ≥ŸÑÿ© ÿßŸÑÿ™Ÿàÿ±ŸäÿØ ŸÖÿπ ÿ∞ŸÉÿßÿ° ÿßÿµÿ∑ŸÜÿßÿπŸä ŸÖÿ™ŸÇÿØŸÖ. ŸÉŸäŸÅ ŸäŸÖŸÉŸÜŸÜŸä ÿ™ÿ≠ÿ≥ŸäŸÜ ŸÑŸàÿ¨ÿ≥ÿ™Ÿäÿßÿ™ŸÉ ÿßŸÑŸäŸàŸÖÿü",
        darija:
          "üåü Ahlan! Ana RawaJAI, expert dyalek f supply chain m3a AI mutaqadim. Kifach n9der n7assan logistique dyalek lyoum?",
      }
      return greetings[language as keyof typeof greetings] || greetings.fr
    }

    return "ü§î Question int√©ressante ! Peux-tu √™tre plus sp√©cifique sur l'aspect supply chain qui t'int√©resse ?"
  }

  // Speech-to-Text R√âEL
  const handleVoiceRecord = async () => {
    if (isRecording) {
      // Arr√™ter l'enregistrement
      setIsRecording(false)
      speechService.current.stopListening()
      return
    }

    try {
      setIsRecording(true)

      if (speechService.current.isSupported()) {
        // Utiliser Web Speech API (plus pr√©cis)
        console.log("üé§ Utilisation Web Speech API...")
        const transcript = await speechService.current.startListening(currentLanguage)

        setInputText(transcript)
        setIsRecording(false)

        Alert.alert(
          "üé§ Transcription termin√©e",
          `J'ai entendu : "${transcript}"\n\nAppuie sur Envoyer pour continuer !`,
          [{ text: "OK" }],
        )
      } else {
        // Fallback avec MediaRecorder + API Whisper
        console.log("üé§ Utilisation MediaRecorder + Whisper...")
        const audioBlob = await speechService.current.startRecordingWithMediaRecorder()
        const transcript = await speechService.current.transcribeAudio(audioBlob)

        setInputText(transcript)
        setIsRecording(false)

        Alert.alert(
          "üé§ Transcription termin√©e",
          `J'ai transcrit : "${transcript}"\n\nAppuie sur Envoyer pour continuer !`,
          [{ text: "OK" }],
        )
      }
    } catch (error) {
      setIsRecording(false)
      console.error("Erreur enregistrement:", error)
      Alert.alert(
        "‚ùå Erreur d'enregistrement",
        `Impossible d'enregistrer l'audio : ${error}\n\nV√©rifie les permissions microphone.`,
        [{ text: "OK" }],
      )
    }
  }

  // Text-to-Speech am√©lior√©
  const speakText = async (text: string, language: string) => {
    if (!speechEnabled) return

    try {
      const cleanText = text
        .replace(/[üéâüëã‚ú®üîßüìäüì¶üööüìàüí°üòäüéØ‚ö°üí™ü§îüöÄüåüü§ùüî¨üìÑü§ñ]/gu, "")
        .replace(/\*\*(.*?)\*\*/g, "$1")
        .replace(/‚Ä¢/g, "")
        .replace(/\n+/g, ". ")
        .replace(/#{1,6}\s/g, "")
        .replace(/üìÑ.*?:/g, "")
        .replace(/ü§ñ.*?:/g, "")
        .trim()
        .substring(0, 500)

      if (cleanText.length < 5) return

      const voiceSettings = {
        fr: { language: "fr-FR", pitch: 1.0, rate: 0.85 },
        en: { language: "en-US", pitch: 1.0, rate: 0.85 },
        ar: { language: "ar-SA", pitch: 1.0, rate: 0.75 },
        darija: { language: "ar-MA", pitch: 1.1, rate: 0.8 },
      }

      const settings = voiceSettings[language as keyof typeof voiceSettings] || voiceSettings.fr

      await Speech.speak(cleanText, {
        ...settings,
        onStart: () => console.log("üîä Lecture d√©marr√©e"),
        onDone: () => console.log("üîä Lecture termin√©e"),
        onError: (error) => console.warn("üîä Erreur lecture:", error),
      })
    } catch (error) {
      console.warn("üîä Erreur Speech:", error)
    }
  }

  // Import de documents intelligent
  const importDocument = async () => {
    try {
      const result = await DocumentPicker.getDocumentAsync({
        type: ["text/plain", "application/pdf", "text/csv", "application/vnd.ms-excel"],
        copyToCacheDirectory: true,
        multiple: false,
      })

      if (!result.canceled && result.assets && result.assets[0]) {
        const file = result.assets[0]
        let content = ""

        try {
          if (file.uri && file.mimeType?.includes("text")) {
            content = await FileSystem.readAsStringAsync(file.uri)
          } else {
            content = generateIntelligentMockContent(file.name)
          }
        } catch (readError) {
          content = generateIntelligentMockContent(file.name)
        }

        const newDoc: Document = {
          id: Date.now().toString(),
          name: file.name,
          content: content,
          type: file.mimeType || "text/plain",
          uploadDate: new Date(),
        }

        ragSystem.current.addDocument(newDoc)
        setDocuments((prev) => [...prev, newDoc])

        Alert.alert(
          "üìÑ Document import√© avec succ√®s !",
          `‚úÖ **${file.name}** ajout√© √† ma base de connaissances.\n\nüß† Je peux maintenant acc√©der directement aux informations pour r√©pondre √† tes questions avec plus de pr√©cision.`,
          [{ text: "Parfait !" }],
        )
      }
    } catch (error) {
      Alert.alert("‚ùå Erreur", "Impossible d'importer le document.")
    }
  }

  // G√©n√©ration de contenu simul√© intelligent
  const generateIntelligentMockContent = (filename: string): string => {
    const lowerName = filename.toLowerCase()

    if (lowerName.includes("stock") || lowerName.includes("inventaire")) {
      return `Rapport Stock - ${filename}

DONN√âES ACTUELLES:
Produit A: 1500 unit√©s (Seuil: 300, Demande: 200/jour)
Produit B: 800 unit√©s (Seuil: 200, Demande: 150/jour)  
Produit C: 1200 unit√©s (Seuil: 150, Demande: 100/jour)

M√âTRIQUES CL√âS:
- Taux de rotation global: 8.2 fois/an
- Co√ªt de stockage: 2.15‚Ç¨/unit√©/mois
- D√©lai r√©approvisionnement moyen: 5.2 jours
- Taux de service actuel: 94.8%

ALERTES CRITIQUES:
‚ö†Ô∏è Produit A: Proche du seuil minimum (risque rupture 3 jours)
‚ö†Ô∏è Produit B: Commande urgente recommand√©e
‚úÖ Produit C: Niveau optimal

RECOMMANDATIONS:
1. Augmenter commande Produit A (+500 unit√©s)
2. R√©viser seuil Produit B (passer √† 250)
3. N√©gocier d√©lais fournisseur (-1 jour)
4. Impl√©menter syst√®me d'alerte automatique`
    }

    if (lowerName.includes("vente") || lowerName.includes("sales")) {
      return `Analyse Ventes - ${filename}

PERFORMANCE MENSUELLE:
Janvier: 15,240‚Ç¨ (1,220 unit√©s) - Croissance: +5.2%
F√©vrier: 18,150‚Ç¨ (1,450 unit√©s) - Croissance: +19.1%
Mars: 22,380‚Ç¨ (1,790 unit√©s) - Croissance: +23.3%
Avril: 19,650‚Ç¨ (1,570 unit√©s) - Croissance: -12.2%

TENDANCES D√âTECT√âES:
üìà Croissance moyenne: +8.9% par mois
üìä Pic saisonnier: Mars (+23.3%)
üìâ Correction naturelle: Avril (-12.2%)
üéØ Pr√©vision Mai: 21,200‚Ç¨ (¬±5%)

TOP PRODUITS (Contribution CA):
1. Produit A: 42% (8,950‚Ç¨/mois)
2. Produit B: 35% (7,450‚Ç¨/mois)
3. Produit C: 23% (4,900‚Ç¨/mois)

INSIGHTS STRAT√âGIQUES:
- Saisonnalit√© forte Q1 (Jan-Mar)
- Produit A = Cash cow (forte marge)
- Produit B = Croissance rapide
- Produit C = Niche stable

ACTIONS RECOMMAND√âES:
1. Booster stock Produit A avant pic
2. Campagne marketing Produit B
3. Optimiser marge Produit C`
    }

    return `Document Supply Chain - ${filename}

SYNTH√àSE EX√âCUTIVE:
Performance globale: 87.3% (Objectif: 90%)
Efficacit√© op√©rationnelle: 91.8%
Satisfaction client: 94.2%
Optimisation co√ªts: 78.5%

INDICATEURS CL√âS:
- D√©lai livraison moyen: 3.2 jours
- Taux de livraison √† temps: 92.1%
- Co√ªt logistique/CA: 4.8%
- Taux de retour: 1.3%

AXES D'AM√âLIORATION:
1. R√©duire d√©lais livraison (-0.5 jour)
2. Am√©liorer pr√©visions (+5% pr√©cision)
3. Optimiser tourn√©es transport (-10% co√ªts)
4. Automatiser processus r√©p√©titifs

PLAN D'ACTION:
Phase 1: Audit complet processus (2 semaines)
Phase 2: Impl√©mentation solutions (1 mois)
Phase 3: Mesure performance (continu)

ROI ESTIM√â: +15% efficacit√©, -8% co√ªts`
  }

  // Effet de frappe (typing effect)
  const addTypingEffect = (text: string, callback: (displayText: string) => void) => {
    let i = 0
    const speed = 30 // ms par caract√®re

    const typeWriter = () => {
      if (i < text.length) {
        callback(text.substring(0, i + 1))
        i++
        setTimeout(typeWriter, speed)
      }
    }

    typeWriter()
  }

  const handleSend = async () => {
    if (!inputText.trim() || isLoading) return

    // D√©tection automatique de la langue
    const detectedLang = detectLanguageUltra(inputText.trim())
    setCurrentLanguage(detectedLang)

    const userMessage: Message = {
      id: Date.now().toString(),
      text: inputText.trim(),
      isUser: true,
      timestamp: new Date(),
      language: detectedLang,
    }

    setMessages((prev) => [...prev, userMessage])

    // Mettre √† jour le contexte
    setChatContext((prev) => ({
      ...prev,
      messages: [...prev.messages, inputText.trim()].slice(-10), // Garder 10 derniers messages
      userPreferences: {
        ...prev.userPreferences,
        language: detectedLang,
      },
    }))

    const currentInput = inputText.trim()
    setInputText("")
    setIsLoading(true)
    setIsTyping(true)

    // Ajouter message de typing
    const typingMessage: Message = {
      id: (Date.now() + 1).toString(),
      text: "üß† Analyse avec IA avanc√©e...",
      isUser: false,
      timestamp: new Date(),
      language: detectedLang,
      isTyping: true,
    }

    setMessages((prev) => [...prev, typingMessage])

    try {
      // G√©n√©ration de r√©ponse ultra-intelligente
      const response = await generateUltraResponse(currentInput, detectedLang)

      // Supprimer le message de typing
      setMessages((prev) => prev.filter((msg) => !msg.isTyping))

      const aiMessage: Message = {
        id: (Date.now() + 2).toString(),
        text: "",
        isUser: false,
        timestamp: new Date(),
        language: detectedLang,
        hasAudio: speechEnabled,
      }

      setMessages((prev) => [...prev, aiMessage])

      // Effet de frappe
      addTypingEffect(response, (displayText) => {
        setMessages((prev) => prev.map((msg) => (msg.id === aiMessage.id ? { ...msg, text: displayText } : msg)))
      })

      // Lecture vocale apr√®s la frappe
      setTimeout(
        () => {
          if (speechEnabled) {
            speakText(response, detectedLang)
          }
        },
        response.length * 30 + 500,
      )
    } catch (error) {
      console.error("Erreur g√©n√©ration r√©ponse:", error)

      setMessages((prev) => prev.filter((msg) => !msg.isTyping))

      const errorMessage: Message = {
        id: (Date.now() + 3).toString(),
        text: "‚ùå D√©sol√©, j'ai rencontr√© un probl√®me. Peux-tu reformuler ta question ?",
        isUser: false,
        timestamp: new Date(),
        language: detectedLang,
      }

      setMessages((prev) => [...prev, errorMessage])
    } finally {
      setIsLoading(false)
      setIsTyping(false)
    }
  }

  const toggleSpeech = () => {
    setSpeechEnabled(!speechEnabled)
    const message = speechEnabled ? "üîá Audio d√©sactiv√©" : "üîä Audio activ√© - Mes r√©ponses seront vocales !"
    Alert.alert("üîä Text-to-Speech", message)
  }

  useEffect(() => {
    scrollViewRef.current?.scrollToEnd({ animated: true })
  }, [messages])

  return (
    <KeyboardAvoidingView
      style={styles.container}
      behavior={Platform.OS === "ios" ? "padding" : "height"}
      keyboardVerticalOffset={Platform.OS === "ios" ? 90 : 0}
    >
      <WebSafeView style={styles.header}>
        <Text style={styles.headerTitle}>üß† RawaJAI IA ULTRA</Text>
        <Text style={styles.headerSubtitle}>
          APIs gratuites ‚Ä¢ {ragSystem.current.getDocumentCount()} docs ‚Ä¢ {currentLanguage.toUpperCase()} ‚Ä¢ Speech R√âEL
        </Text>

        <WebSafeView style={styles.controlsRow}>
          <WebSafeView style={styles.statusIndicator}>
            <Text style={styles.statusText}>üåç {currentLanguage.toUpperCase()}</Text>
          </WebSafeView>

          <WebSafeTouchableOpacity
            style={[styles.audioButton, speechEnabled && styles.audioButtonActive]}
            onPress={toggleSpeech}
          >
            <Text style={styles.audioButtonText}>{speechEnabled ? "üîä" : "üîá"}</Text>
          </WebSafeTouchableOpacity>

          <WebSafeTouchableOpacity style={styles.docButton} onPress={importDocument}>
            <Text style={styles.docButtonText}>üìÑ</Text>
          </WebSafeTouchableOpacity>

          <WebSafeView style={styles.aiIndicator}>
            <Text style={styles.aiIndicatorText}>ü§ñ AI</Text>
          </WebSafeView>
        </WebSafeView>
      </WebSafeView>

      <ScrollView ref={scrollViewRef} style={styles.messagesContainer} showsVerticalScrollIndicator={false}>
        {messages.map((message) => (
          <WebSafeView
            key={message.id}
            style={[
              styles.messageContainer,
              message.isUser ? styles.userMessage : styles.aiMessage,
              message.isTyping && styles.typingMessage,
            ]}
          >
            <Text style={[styles.messageText, message.isUser ? styles.userMessageText : styles.aiMessageText]}>
              {message.text}
            </Text>
            {!message.isTyping && (
              <WebSafeView style={styles.messageFooter}>
                <Text style={styles.timestamp}>
                  {message.timestamp.toLocaleTimeString("fr-FR", { timeStyle: "short" })}
                </Text>
                <WebSafeView style={styles.messageIcons}>
                  {message.hasAudio && <Text style={styles.audioIcon}>üîä</Text>}
                  <Text style={styles.languageTag}>{message.language.toUpperCase()}</Text>
                </WebSafeView>
              </WebSafeView>
            )}
          </WebSafeView>
        ))}
      </ScrollView>

      <WebSafeView style={styles.inputContainer}>
        <WebSafeView style={styles.inputRow}>
          <TextInput
            style={styles.textInput}
            value={inputText}
            onChangeText={setInputText}
            placeholder="Tapez ou parlez (üé§) - IA d√©tecte automatiquement..."
            placeholderTextColor="#999"
            multiline
            maxLength={500}
            onSubmitEditing={handleSend}
            editable={!isLoading}
          />

          <WebSafeTouchableOpacity
            style={[styles.voiceButton, isRecording && styles.voiceButtonActive]}
            onPress={handleVoiceRecord}
            disabled={isLoading}
          >
            <Text style={styles.voiceButtonText}>{isRecording ? "‚èπÔ∏è" : "üé§"}</Text>
          </WebSafeTouchableOpacity>

          <WebSafeTouchableOpacity
            style={[styles.sendButton, (!inputText.trim() || isLoading) && styles.sendButtonDisabled]}
            onPress={handleSend}
            disabled={!inputText.trim() || isLoading}
          >
            <Text style={styles.sendButtonText}>‚û§</Text>
          </WebSafeTouchableOpacity>
        </WebSafeView>

        <WebSafeView style={styles.quickActions}>
          <WebSafeTouchableOpacity style={styles.quickButton} onPress={() => setInputText("aide compl√®te")}>
            <Text style={styles.quickButtonText}>üí° Aide</Text>
          </WebSafeTouchableOpacity>

          <WebSafeTouchableOpacity style={styles.quickButton} onPress={() => setInputText("optimiser mes pr√©visions")}>
            <Text style={styles.quickButtonText}>üìä Pr√©visions</Text>
          </WebSafeTouchableOpacity>

          <WebSafeTouchableOpacity style={styles.quickButton} onPress={() => setInputText("analyser mon stock")}>
            <Text style={styles.quickButtonText}>üì¶ Stock</Text>
          </WebSafeTouchableOpacity>

          <WebSafeTouchableOpacity style={styles.quickButton} onPress={() => setInputText("am√©liorer ma logistique")}>
            <Text style={styles.quickButtonText}>üöö Logistique</Text>
          </WebSafeTouchableOpacity>
        </WebSafeView>
      </WebSafeView>
    </KeyboardAvoidingView>
  )
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: "#f5f7fa",
  },
  header: {
    backgroundColor: "#fff",
    paddingTop: Platform.OS === "ios" ? 50 : 20,
    paddingBottom: 15,
    paddingHorizontal: 20,
    borderBottomWidth: 1,
    borderBottomColor: "#e1e8ed",
  },
  headerTitle: {
    fontSize: 24,
    fontWeight: "bold",
    color: "#1a202c",
    textAlign: "center",
  },
  headerSubtitle: {
    fontSize: 12,
    color: "#718096",
    textAlign: "center",
    marginTop: 4,
  },
  controlsRow: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginTop: 12,
  },
  statusIndicator: {
    backgroundColor: "#f1f5f9",
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 16,
    borderWidth: 1,
    borderColor: "#e2e8f0",
  },
  statusText: {
    fontSize: 12,
    color: "#475569",
    fontWeight: "600",
  },
  audioButton: {
    width: 32,
    height: 32,
    borderRadius: 16,
    backgroundColor: "#f1f5f9",
    justifyContent: "center",
    alignItems: "center",
    borderWidth: 1,
    borderColor: "#e2e8f0",
  },
  audioButtonActive: {
    backgroundColor: "#10B981",
    borderColor: "#10B981",
  },
  audioButtonText: {
    fontSize: 16,
  },
  docButton: {
    width: 32,
    height: 32,
    borderRadius: 16,
    backgroundColor: "#f1f5f9",
    justifyContent: "center",
    alignItems: "center",
    borderWidth: 1,
    borderColor: "#e2e8f0",
  },
  docButtonText: {
    fontSize: 16,
  },
  aiIndicator: {
    backgroundColor: "#3B82F6",
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
  },
  aiIndicatorText: {
    fontSize: 10,
    color: "white",
    fontWeight: "600",
  },
  messagesContainer: {
    flex: 1,
    paddingHorizontal: 16,
    paddingVertical: 10,
  },
  messageContainer: {
    marginVertical: 4,
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderRadius: 18,
    maxWidth: "85%",
  },
  userMessage: {
    alignSelf: "flex-end",
    backgroundColor: "#007AFF",
  },
  aiMessage: {
    alignSelf: "flex-start",
    backgroundColor: "#fff",
    borderWidth: 1,
    borderColor: "#e1e8ed",
  },
  typingMessage: {
    backgroundColor: "#f8f9fa",
    borderColor: "#3B82F6",
  },
  messageText: {
    fontSize: 16,
    lineHeight: 22,
  },
  userMessageText: {
    color: "#fff",
  },
  aiMessageText: {
    color: "#1a202c",
  },
  messageFooter: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    marginTop: 6,
  },
  timestamp: {
    fontSize: 12,
    color: "#718096",
  },
  messageIcons: {
    flexDirection: "row",
    alignItems: "center",
    gap: 4,
  },
  audioIcon: {
    fontSize: 12,
  },
  languageTag: {
    fontSize: 10,
    color: "#9CA3AF",
    backgroundColor: "#F3F4F6",
    paddingHorizontal: 6,
    paddingVertical: 2,
    borderRadius: 8,
    fontWeight: "600",
  },
  inputContainer: {
    backgroundColor: "#fff",
    paddingHorizontal: 16,
    paddingVertical: 12,
    borderTopWidth: 1,
    borderTopColor: "#e1e8ed",
  },
  inputRow: {
    flexDirection: "row",
    alignItems: "flex-end",
    gap: 8,
    marginBottom: 8,
  },
  textInput: {
    flex: 1,
    borderWidth: 1,
    borderColor: "#e1e8ed",
    borderRadius: 20,
    paddingHorizontal: 16,
    paddingVertical: 12,
    fontSize: 16,
    maxHeight: 100,
    backgroundColor: "#f8f9fa",
  },
  voiceButton: {
    width: 44,
    height: 44,
    borderRadius: 22,
    backgroundColor: "#f8f9fa",
    borderWidth: 1,
    borderColor: "#e1e8ed",
    justifyContent: "center",
    alignItems: "center",
  },
  voiceButtonActive: {
    backgroundColor: "#ff4757",
    borderColor: "#ff4757",
  },
  voiceButtonText: {
    fontSize: 18,
  },
  sendButton: {
    width: 44,
    height: 44,
    borderRadius: 22,
    backgroundColor: "#007AFF",
    justifyContent: "center",
    alignItems: "center",
  },
  sendButtonDisabled: {
    backgroundColor: "#cbd5e0",
  },
  sendButtonText: {
    color: "#fff",
    fontSize: 18,
    fontWeight: "bold",
  },
  quickActions: {
    flexDirection: "row",
    gap: 6,
    justifyContent: "center",
    flexWrap: "wrap",
  },
  quickButton: {
    backgroundColor: "#f1f5f9",
    paddingHorizontal: 10,
    paddingVertical: 6,
    borderRadius: 16,
    borderWidth: 1,
    borderColor: "#e2e8f0",
  },
  quickButtonText: {
    fontSize: 11,
    color: "#475569",
    fontWeight: "500",
  },
})
