import Constants from 'expo-constants';
import * as SecureStore from 'expo-secure-store';
import { Platform } from 'react-native';

// Default API URL - for local dev testing
const DEFAULT_API_URL = 'https://literacy-challenging-graduates-andrews.trycloudflare.com';
const API_URL = Constants.expoConfig?.extra?.apiUrl || DEFAULT_API_URL;
const TUNNEL_KEY = 'https://literacy-challenging-graduates-andrews.trycloudflare.com';

// Type definitions for API requests and responses
export interface ForecastParams {
  product_id: string;
  days?: number;
  language?: string;
}

export interface OptimizeInventoryParams {
  forecast_data: any[];
  product_id: string;
  holding_cost: number;
  ordering_cost: number;
  lead_time: number;
  service_level: number;
  language?: string;
}

export interface QuestionParams {
  query: string;
  language?: string;
}

export interface AnomalyDetectionParams {
  product_id: string;
  language?: string;
}

export interface ScenarioAnalysisParams {
  product_id: string;
  scenario: string;
  language?: string;
}

export interface ReportParams {
  report_type: 'forecast' | 'inventory';
  product_id?: string;
  language?: string;
}

export interface DocumentParams {
  document: string;
  language?: string;
}

export interface AudioUploadParams {
  uri: string;
  name: string;
  type: string;
  language?: string;
}

/**
 * Storage Functions for Cloudflare Tunnel URL
 */
export const saveTunnelUrl = async (url: string) => {
  try {
    await SecureStore.setItemAsync(TUNNEL_KEY, url);
    return true;
  } catch (error) {
    console.error('Failed to save tunnel URL:', error);
    return false;
  }
};

export const getTunnelUrl = async (): Promise<string | null> => {
  try {
    return await SecureStore.getItemAsync(TUNNEL_KEY);
  } catch (error) {
    console.error('Failed to get tunnel URL:', error);
    return null;
  }
};

export const clearTunnelUrl = async () => {
  try {
    await SecureStore.deleteItemAsync(TUNNEL_KEY);
    return true;
  } catch (error) {
    console.error('Failed to clear tunnel URL:', error);
    return false;
  }
};

/**
 * API Base Functions
 */
const getBaseUrl = async () => {
  // Try to use the tunnel URL first
  const tunnelUrl = await getTunnelUrl();
  if (tunnelUrl) return tunnelUrl;
  
  // For Android emulators, localhost refers to the emulator itself, not your machine
  if (Platform.OS === 'android') {
    return API_URL.replace('localhost', '10.0.2.2');
  }
  
  return API_URL;
};

/**
 * API request function with timeout
 */
const fetchWithTimeout = async (url: string, options: RequestInit = {}, timeout = 10000) => {
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), timeout);
  
  const response = await fetch(url, {
    ...options,
    signal: controller.signal,
  });
  
  clearTimeout(id);
  return response;
};

/**
 * API client class
 */
export class ApiClient {
  /**
   * Base API request method
   */
  async request(
    endpoint: string, 
    method = 'GET', 
    params: Record<string, any> = {}, 
    body: Record<string, any> = {}, 
    isFormData = false
  ) {
    try {
      const baseUrl = await getBaseUrl();
      const url = new URL(`${baseUrl}${endpoint}`);
      
      // Add query parameters for GET requests
      if (method === 'GET' && Object.keys(params).length > 0) {
        Object.keys(params).forEach(key => {
          if (params[key] !== undefined && params[key] !== null) {
            url.searchParams.append(key, String(params[key]));
          }
        });
      }
      
      // Prepare headers
      const headers: HeadersInit = {};
      if (!isFormData) {
        headers['Content-Type'] = 'application/json';
      }
      
      // Prepare options
      const options: RequestInit = {
        method,
        headers,
      };
      
      // Add body for non-GET requests
      if (method !== 'GET' && Object.keys(body).length > 0) {
        options.body = isFormData ? (body as unknown as FormData) : JSON.stringify(body);
      }
      
      // Make the request
      const response = await fetchWithTimeout(url.toString(), options);
      
      // Handle error responses
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `API Error: ${response.status} ${response.statusText}`);
      }
      
      // Special case for binary responses (like PDFs)
      if (response.headers.get('content-type')?.includes('application/pdf')) {
        return { blob: await response.blob(), url: response.url };
      }
      
      // Parse JSON response
      const data = await response.json().catch(() => ({}));
      return data;
    } catch (error) {
      console.error(`API request failed: ${(error as Error).message}`);
      throw error;
    }
  }
  
  /**
   * Tunnel Management API methods
   */
  async getTunnelStatus() {
    return this.request('/tunnel/status');
  }
  
  async startTunnel() {
    return this.request('/tunnel/start', 'POST');
  }
  
  async stopTunnel() {
    return this.request('/tunnel/stop', 'POST');
  }
  
  async testTunnel() {
    return this.request('/tunnel/test');
  }
  
  /**
   * Supply Chain API Methods
   */
  async getForecast(data: ForecastParams) {
    return this.request('/forecast', 'POST', {}, data);
  }
  
  async optimizeInventory(data: OptimizeInventoryParams) {
    return this.request('/optimize', 'POST', {}, data);
  }
  
  async askQuestion(query: string, language = 'en') {
    return this.request('/ask', 'POST', {}, { query, language });
  }
  
  async detectAnomalies(data: AnomalyDetectionParams) {
    return this.request('/anomaly_detection', 'POST', {}, data);
  }
  
  async analyzeScenario(data: ScenarioAnalysisParams) {
    return this.request('/scenario_analysis', 'POST', {}, data);
  }
  
  async generateReport(data: ReportParams) {
    const response = await this.request('/generate_report', 'POST', {}, data);
    return response;
  }
  
  async addDocument(document: string, language = 'en') {
    return this.request('/add_document', 'POST', {}, { document, language });
  }
  
  async uploadAudio(audioFile: AudioUploadParams) {
    const formData = new FormData();
    // @ts-ignore - React Native's FormData has different typing than web FormData
    formData.append('audio', {
      uri: audioFile.uri,
      name: audioFile.name || 'audio.m4a',
      type: audioFile.type || 'audio/m4a',
    });
    
    if (audioFile.language) {
      formData.append('language', audioFile.language);
    }
    
    return this.request('/upload_audio', 'POST', {}, formData as unknown as Record<string, any>, true);
  }
}

// Export a singleton instance of the API client
export const api = new ApiClient();
